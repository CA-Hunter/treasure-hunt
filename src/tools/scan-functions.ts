// run this script manually:
// npx ts-node -P tsconfig.tools.json src/tools/scan-functions.ts [all|user|frontend] [llm|blank|info]

import { readdir, readFile, writeFile } from 'node:fs/promises'
import { join, resolve } from 'node:path'
import * as ts from 'typescript'

type ScanMode = 'all' | 'user' | 'frontend'

interface FunctionInfo {
    name: string
    filePath: string
    description?: string
    functionType: string
    parameters: {
        name: string
        type: string
        description?: string
        isOptional: boolean
    }[]
    returnType?: string
    accessibility?: {
        level: string
        capabilities: string[]
    }
}

class FunctionScanner {
    private functions: FunctionInfo[] = []
    private scanMode: ScanMode
    private fillMode: 'llm' | 'blank' | 'info'

    constructor(mode: ScanMode = 'all', fillMode: 'llm' | 'blank' | 'info' = 'blank') {
        this.scanMode = mode
        this.fillMode = fillMode
    }

    async scanProject(basePath: string): Promise<FunctionInfo[]> {
        try {
            await this.scanDir(resolve(basePath))
            return this.functions
        } catch (error) {
            console.error('Error scanning project:', error)
            return []
        }
    }

    private async scanDir(dir: string) {
        const entries = await readdir(dir, { withFileTypes: true })
        
        for (const entry of entries) {
            const fullPath = join(dir, entry.name)
            
            if (entry.isDirectory() && !entry.name.startsWith('.') && entry.name !== 'node_modules') {
                await this.scanDir(fullPath)
            } else if (entry.name.endsWith('.ts') || entry.name.endsWith('.tsx')) {
                await this.scanFile(fullPath)
            }
        }
    }

    private async scanFile(filePath: string) {
        const content = await readFile(filePath, 'utf-8')
        const sourceFile = ts.createSourceFile(
            filePath,
            content,
            ts.ScriptTarget.Latest,
            true
        )

        this.visitNode(sourceFile, filePath)
    }

    private visitNode(node: ts.Node, filePath: string) {
        if (ts.isFunctionDeclaration(node) || ts.isMethodDeclaration(node)) {
            const functionType = this.getFunctionType(node, filePath)
            
            if (this.shouldIncludeFunction(functionType)) {
                const functionInfo = this.extractFunctionInfo(node, filePath, functionType)
                if (functionInfo) {
                    this.functions.push(functionInfo)
                }
            }
        }

        node.forEachChild(child => this.visitNode(child, filePath))
    }

    private getFunctionType(node: ts.Node, filePath: string): string {
        if (filePath.includes('/components/') || filePath.endsWith('.tsx')) {
            return 'frontend'
        }
        
        const name = (ts.isFunctionDeclaration(node) || ts.isMethodDeclaration(node))
            ? node.name?.getText().toLowerCase() || ''
            : ''
        
        if (['handle', 'on', 'click', 'submit', 'change'].some(prefix => name.includes(prefix))) {
            return 'user'
        }
        
        return 'other'
    }

    private shouldIncludeFunction(functionType: string): boolean {
        return this.scanMode === 'all' 
            || (this.scanMode === 'user' && functionType === 'user')
            || (this.scanMode === 'frontend' && functionType === 'frontend')
    }

    private generateDescription(
        name: string,
        parameters: Array<{ name: string; type: string }>,
        returnType?: string
    ): string {
        switch (this.fillMode) {
            case 'llm':
                // Placeholder for LLM integration
                return `Function ${name} - Description to be generated by LLM`
            case 'info':
                return `${name}: Accepts ${parameters.length} parameters, returns ${returnType || 'void'}`
            default:
                return `${name} function`
        }
    }

    private extractFunctionInfo(
        node: ts.FunctionDeclaration | ts.MethodDeclaration,
        filePath: string,
        functionType: string
    ): FunctionInfo | null {
        if (!node.name) return null

        const name = node.name.getText()
        const parameters = node.parameters.map(param => ({
            name: param.name.getText(),
            type: param.type?.getText() || 'any',
            isOptional: !!param.questionToken,
            description: ''
        }))
        const returnType = node.type?.getText()

        const info: FunctionInfo = {
            name,
            filePath: filePath.replace(process.cwd(), ''),
            functionType,
            parameters,
            returnType,
            description: this.generateDescription(name, parameters, returnType),
            accessibility: {
                level: 'ENHANCED',
                capabilities: ['SCREEN_READER']
            }
        }

        return info
    }


    async generateRegistryFile(outputPath: string) {
        const registryData = {
            timestamp: new Date().toISOString(),
            scanMode: this.scanMode,
            functions: this.functions
        }

        await writeFile(outputPath, JSON.stringify(registryData, null, 2))
        console.log(`Generated registry with ${this.functions.length} functions`)
    }
}

async function main() {
    const mode = process.argv[2]?.toLowerCase() as ScanMode || 'all'
    const scanner = new FunctionScanner(mode)
    await scanner.scanProject('./src')
    await scanner.generateRegistryFile('./src/services/accessibility/registry-data.json')
}

if (require.main === module) {
    main().catch(console.error)
}

export { FunctionScanner, type FunctionInfo, type ScanMode }

